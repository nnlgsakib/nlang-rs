// Advanced Features Test - Demonstrates complex nlang capabilities
// This file tests: complex expressions, nested calls, advanced control flow, 
// function composition, recursive patterns, and edge cases

def main() {
    println("=== Advanced Features Test ===");
    println("");
    
    // Complex nested expressions
    println("--- Complex Mathematical Expressions ---");
    store complex_result = calculate_complex_expression(10, 5, 3);
    println("Complex expression calculated successfully");
    
    store nested_calls = process_nested_data(
        transform_data(generate_data(42)),
        validate_and_process(100, 200)
    );
    println("Nested function calls completed");
    println("");
    
    // Advanced control flow with complex conditions
    println("--- Advanced Control Flow ---");
    store advanced_flow = advanced_control_flow_demo(15, 25, 35);
    println("Advanced control flow executed");
    println("");
    
    // Function composition and chaining
    println("--- Function Composition and Chaining ---");
    store composed_result = compose_functions(7);
    println("Function composition completed");
    println("");
    
    // Recursive pattern demonstrations
    println("--- Recursive Patterns ---");
    store fibonacci_result = fibonacci_iterative(10);
    println("Fibonacci(10) calculated");
    
    store tower_moves = towers_of_hanoi(4);
    println("Towers of Hanoi(4) moves calculated");
    println("");
    
    // Complex data processing
    println("--- Complex Data Processing ---");
    store processed_array = simulate_array_operations();
    println("Array operations completed");
    println("");
    
    // Edge case testing
    println("--- Edge Case Testing ---");
    store edge_cases = test_edge_cases();
    println("Edge cases testing completed");
    println("");
    
    // Performance and complexity testing
    println("--- Performance Testing ---");
    store performance_result = performance_test(1000);
    println("Performance test (1000 iterations) completed");
    println("");
    
    println("=== Advanced Features Test Completed! ===");
}

// Complex mathematical expression with multiple operations
def calculate_complex_expression(a: int, b: int, c: int): float {
    // Nested arithmetic with type promotion
    store part1 = (a * b + c) / (a - b);
    store part2 = power_recursive(a, 2) + power_recursive(b, 2);
    store part3 = factorial_tail_recursive(c, 1);
    
    // Complex conditional expression
    if (part1 > 0.0 && part2 > part3) {
        return part1 * 2.0 + (part2 * 1.0) / (part3 * 1.0);
    } else if (part1 < 0.0 || part2 == 0) {
        return abs_float(part1) + (part2 * 1.0) * 0.5;
    } else {
        return part1 + (part2 * 1.0) - (part3 * 1.0);
    }
}

// Nested function calls with data transformation
def process_nested_data(data1: int, data2: int): int {
    return combine_results(
        apply_transformation(data1, multiply_by_factor(2)),
        apply_transformation(data2, add_offset(10))
    );
}

def generate_data(seed: int): int {
    return seed * 3 + 7;
}

def transform_data(value: int): int {
    if (value > 100) {
        return value - 50;  // Changed from division to subtraction to keep int type
    } else {
        return value * 2;
    }
}

def validate_and_process(x: int, y: int): int {
    if (x > 0 && y > 0) {
        return max_of_three(x, y, x + y);
    } else {
        return 0;
    }
}

def combine_results(a: int, b: int): int {
    return a * b + min_of_three(a, b, a - b);
}

def apply_transformation(value: int, factor: int): int {
    return value * factor + factor - 1;  // Changed from division to subtraction to keep int type
}

def multiply_by_factor(factor: int): int {
    return factor;
}

def add_offset(offset: int): int {
    return offset;
}

// Advanced control flow with complex nested conditions
def advanced_control_flow_demo(x: int, y: int, z: int): string {
    if (x > 10) {
        if (y > 20) {
            if (z > 30) {
                return "All conditions met";
            } else {
                while (z < 30) {
                    z = z + 1;
                    if (z % 5 == 0) {
                        return "Z reached multiple of 5";
                    }
                }
                return "Z loop completed";
            }
        } else {
            store counter = 0;
            while (counter < y) {
                counter = counter + 1;
                if (counter * x > 100) {
                    return "Counter exceeded threshold";
                }
            }
            return "Y loop completed";
        }
    } else {
        if (is_prime_simple(x)) {
            return "X is prime";
        } else if (is_perfect_square(x)) {
            return "X is perfect square";
        } else {
            return "X is neither prime nor perfect square";
        }
    }
}

// Function composition and chaining
def compose_functions(value: int): int {
    return chain_step_four(
        chain_step_three(
            chain_step_two(
                chain_step_one(value)
            )
        )
    );
}

def chain_step_one(x: int): int {
    return x * 2 + 1;
}

def chain_step_two(x: int): int {
    return x * x - 3;
}

def chain_step_three(x: int): int {
    if (x > 50) {
        return x - 25;  // Changed from division to subtraction to keep int type
    } else {
        return x + 10;
    }
}

def chain_step_four(x: int): int {
    return x % 100 + 5;
}

// Recursive patterns - Fibonacci iterative approach
def fibonacci_iterative(n: int): int {
    if (n <= 1) {
        return n;
    }
    
    store prev = 0;
    store curr = 1;
    store i = 2;
    
    while (i <= n) {
        store next = prev + curr;
        prev = curr;
        curr = next;
        i = i + 1;
    }
    
    return curr;
}

// Towers of Hanoi - calculate number of moves
def towers_of_hanoi(n: int): int {
    if (n == 1) {
        return 1;
    } else {
        return 2 * towers_of_hanoi(n - 1) + 1;
    }
}

// Tail recursive factorial
def factorial_tail_recursive(n: int, accumulator: int): int {
    if (n <= 1) {
        return accumulator;
    } else {
        return factorial_tail_recursive(n - 1, n * accumulator);
    }
}

// Power function using recursion
def power_recursive(base: int, exponent: int): int {
    if (exponent == 0) {
        return 1;
    } else if (exponent == 1) {
        return base;
    } else if (exponent % 2 == 0) {
        store half_exp = exponent - 1;  // Changed from division to avoid float
        store half_power = power_recursive(base, half_exp);
        return half_power * half_power;
    } else {
        return base * power_recursive(base, exponent - 1);
    }
}

// Simulate array-like operations using multiple variables
def simulate_array_operations(): int {
    // Simulate array initialization
    store arr0 = 10;
    store arr1 = 20;
    store arr2 = 30;
    store arr3 = 40;
    store arr4 = 50;
    
    // Simulate array processing
    store sum = arr0 + arr1 + arr2 + arr3 + arr4;
    store max_val = max_of_five(arr0, arr1, arr2, arr3, arr4);
    store min_val = min_of_five(arr0, arr1, arr2, arr3, arr4);
    
    // Simulate array transformation
    arr0 = arr0 * 2;
    arr1 = arr1 * 2;
    arr2 = arr2 * 2;
    arr3 = arr3 * 2;
    arr4 = arr4 * 2;
    
    store new_sum = arr0 + arr1 + arr2 + arr3 + arr4;
    
    return new_sum - sum;
}

// Utility functions for complex operations
def max_of_three(a: int, b: int, c: int): int {
    if (a >= b && a >= c) {
        return a;
    } else if (b >= c) {
        return b;
    } else {
        return c;
    }
}

def min_of_three(a: int, b: int, c: int): int {
    if (a <= b && a <= c) {
        return a;
    } else if (b <= c) {
        return b;
    } else {
        return c;
    }
}

def max_of_five(a: int, b: int, c: int, d: int, e: int): int {
    return max_of_three(max_of_three(a, b, c), d, e);
}

def min_of_five(a: int, b: int, c: int, d: int, e: int): int {
    return min_of_three(min_of_three(a, b, c), d, e);
}

def abs_float(x: float): float {
    if (x < 0.0) {
        return -x;
    } else {
        return x;
    }
}

def is_prime_simple(n: int): bool {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return true;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    
    store i = 5;
    while (i * i <= n) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
        i = i + 6;
    }
    return true;
}

def is_perfect_square(n: int): bool {
    if (n < 0) {
        return false;
    }
    
    store i = 0;
    while (i * i <= n) {
        if (i * i == n) {
            return true;
        }
        i = i + 1;
    }
    return false;
}

// Edge cases testing
def test_edge_cases(): bool {
    // Test with zero values
    store zero_test = calculate_with_zero(0, 10);
    
    // Test with negative values
    store negative_test = handle_negative_values(-5, -10);
    
    // Test with large values
    store large_test = handle_large_values(999, 1000);
    
    // Test boundary conditions
    store boundary_test = test_boundaries(1, 2);
    
    return zero_test && negative_test && large_test && boundary_test;
}

def calculate_with_zero(a: int, b: int): bool {
    if (a == 0) {
        return b > 0;
    } else {
        return a * b > 0;
    }
}

def handle_negative_values(x: int, y: int): bool {
    if (x < 0 && y < 0) {
        return (x * y) > 0;
    } else if (x < 0 || y < 0) {
        return (x + y) < 0;
    } else {
        return true;
    }
}

def handle_large_values(a: int, b: int): bool {
    if (a > 500 && b > 500) {
        return (a + b) > 1000;
    } else {
        return false;
    }
}

def test_boundaries(min_val: int, max_val: int): bool {
    return min_val < max_val && max_val > 0;
}

// Performance testing with loops
def performance_test(iterations: int): int {
    store result = 0;
    store i = 0;
    
    while (i < iterations) {
        result = result + complex_calculation(i);
        i = i + 1;
    }
    
    return result;
}

def complex_calculation(n: int): int {
    store temp = n * 3 + 7;
    temp = temp % 100;
    
    if (temp > 50) {
        temp = temp - 25;
    } else {
        temp = temp + 25;
    }
    
    return temp * 2;
}